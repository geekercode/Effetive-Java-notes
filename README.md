 Effective-java-notes
 - 
  创建于2018.07.11，Effective Java 78 条规则  
  
 *effective java 读书笔记，欢迎交流和讨论*
## 创建和销毁对象
一、考虑用静态工厂方法代替构造器   

二、遇到多个构造参数时要考虑用构建器(Builder模式)   

三、用私有构造器或者枚举类型强化Singleton属性   

四、通过私有构造器强化不可实例化的能力   

五、避免创建不必要的对象   

六、消除过期的对象引用   

七、避免使用终结方法

## 对象通用方法
八、覆盖equals时请遵守通用约定   

九、覆盖equals时总要覆盖hashCode   

十、始终要覆盖toString   

十一、谨慎地覆盖clone   

十二、考虑实现Comparable接口 

## 类和接口
十三、使类和成员的可访问性最小化   

十四、在公有类中使用访问方法而非公有域   

十五、使可变性最小化   

十六、复合优先于继承  

十七、要么为继承而设计，并提供文档说明，要么就禁止继承   

十八、接口优先于抽象类   

十九、接口只用于定义类型    

二十、类层次优于标签类   

二十一、用函数对象表示策略   

二十二、优先考虑静态成员类

## 泛型
二十三、请不要在新代码中使用原生态类型   

二十四、消除非受检警告   

二十五、列表优先于数组   

二十六、优先考虑泛型   

二十七、优先考虑泛型方法 

二十八、利用有限制通配符来提升API的灵活性 

二十九、优先考虑类型安全的异构容器

## 枚举
三十、用enum代替int常量 

三十一、用实例域代替序数 

三十二、用EnumSet代替位域 

三十三、用EnumMap代替序数索引 

三十四、用接口模拟可伸缩的枚举 

三十五、注解优先于命名模式 

三十六、坚持使用Override注解 

三十七、用标记接口定义类型

## 方法
三十八、检查参数的有效性 

三十九、必要时进行保护性拷贝 

四十、谨慎设计方法签名 

四十一、谨慎重载 

四十二、慎用可变参数 

四十三、返回零长度的数组或者集合，而不是null 

四十四、为所有导出的API元素编写文档注释

## 通用程序设计
四十五、将局部变量的作用域最小化 

四十六、for-each循环优先于传统的for循环 

四十七、了解和使用类库

四十八、如果需要精确的答案，请避免使用float和double 

四十九、基本类型优先于基本装箱类型 

五十、如果其他类型更合适，则尽量避免使用字符串 

五十一、当心字符串连接的性能 

五十二、通过接口引用对象 

五十三、接口优先于反射机制 

五十四、谨慎地使用本地方法 

五十五、谨慎地进行优化 

五十六、遵守普遍接受的命名惯例

## 异常
五十七、只针对异常情况才使用异常 

五十八、对可恢复的情况使用受检异常，对编程错误使用运行时异常 

五十九、避免不必要的使用受检异常 

六十、优先使用标准异常 

六十一、抛出与抽象相对应的异常 

六十三、在细节中包含能捕获失败的信息 

六十四、努力使失败保持原子性 

六十五、不要忽略异常

## 并发
六十六、同步访问共享的可变数据 

六十七、避免过度同步 

六十八、executor和task优先于线程 

六十九、并发工具优先于wait和notify 

七十、线程安全性的文档化 

七十一、慎用延迟初始化 

七十二、不要依赖于线程调度 

七十三、避免使用线程组

## 序列化
七十四、谨慎地实现Serializable接口 

七十五、考虑使用自定义的序列化形式 

七十六、保护性的编写readObject方法 

七十七、对于实例控制，枚举类型优先于readResolve 

七十八、考虑用序列化代理代替序列化实例
